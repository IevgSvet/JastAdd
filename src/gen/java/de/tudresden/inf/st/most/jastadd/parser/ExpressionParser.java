// Generated from /home/ievgeniia/Documents/MQuAT/jastadd_ex/build/tmp/preprocessParser/ExpressionParser.all
package de.tudresden.inf.st.most.jastadd.parser;
 import de.tudresden.inf.st.most.jastadd.ast.*; 
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ExpressionParser.beaver".
 */
public class ExpressionParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short MINUS = 1;
		static public final short NUMBER = 2;
		static public final short IDENTIFIER = 3;
		static public final short LP = 4;
		static public final short RP = 5;
		static public final short PLUS = 6;
		static public final short MULT = 7;
		static public final short DIV = 8;
		static public final short NEWLINE = 9;
		static public final short EQUALS = 10;

		static public final String[] NAMES = {
			"EOF",
			"MINUS",
			"NUMBER",
			"IDENTIFIER",
			"LP",
			"RP",
			"PLUS",
			"MULT",
			"DIV",
			"NEWLINE",
			"EQUALS"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9ojaJjFmq0GX2SE9ZXs71B2CuGW10q28Hee4HKb1GK51GK51GK51Gq5Vnc7F7Wki#ipEbm" +
		"W2cxqQMV7v$Yo1#11dj76548HkXaqCIylL2QVg9bJZMMC2CkegpCDP80Lz92eCsMIOHOjpA" +
		"apJMI23XQmgCuqaX5MqSMQEjDGXh2bpheO3InX6W7wgCfJqSjxBkjJFlzZbJUdLwUFNFnaX" +
		"NiIrf2xQ$plckYAVoGnwkpzfCApbVU4fIJl$IJYMv6VYAtlH7#roflGC#d9Y$w$Ax3#c8$y" +
		"X6X$IdGEP#GyVuGBqY8HkIHjqYMRv8fia5roJRR90RaXE#J8PWZUD718ziWjsITtvDvz$rW" +
		"hHp3MwhB0rSZBEeLtVTVpFSzl#Vj#mwtKffnoBWtM1cl2sqZi3a97KF8Le$a5$qgYJW==");

	public ExpressionParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new Root(new List<Def>(), exp);
			}
			case 1: // goal = def_list.def_list exp.exp
			{
					final Symbol _symbol_def_list = _symbols[offset + 1];
					final List def_list = (List) _symbol_def_list.value;
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new Root(def_list, exp);
			}
			case 2: // def_list = def.def
			{
					final Symbol _symbol_def = _symbols[offset + 1];
					final Def def = (Def) _symbol_def.value;
					 return new List().add(def);
			}
			case 3: // def_list = def_list.def_list def.def
			{
					final Symbol _symbol_def_list = _symbols[offset + 1];
					final List def_list = (List) _symbol_def_list.value;
					final Symbol _symbol_def = _symbols[offset + 2];
					final Def def = (Def) _symbol_def.value;
					 return def_list.add(def);
			}
			case 4: // def = IDENTIFIER.IDENTIFIER EQUALS.EQUALS MINUS.MINUS NUMBER.NUMBER NEWLINE.NEWLINE
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol MINUS = _symbols[offset + 3];
					final Symbol NUMBER = _symbols[offset + 4];
					final Symbol NEWLINE = _symbols[offset + 5];
					 return new Def((String)IDENTIFIER.value, -Float.parseFloat((String)NUMBER.value));
			}
			case 5: // def = IDENTIFIER.IDENTIFIER EQUALS.EQUALS NUMBER.NUMBER NEWLINE.NEWLINE
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol NUMBER = _symbols[offset + 3];
					final Symbol NEWLINE = _symbols[offset + 4];
					 return new Def((String)IDENTIFIER.value, Float.parseFloat((String)NUMBER.value));
			}
			case 6: // exp = LP.LP exp.a PLUS.PLUS exp.b RP.RP
			{
					final Symbol LP = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol PLUS = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Exp b = (Exp) _symbol_b.value;
					final Symbol RP = _symbols[offset + 5];
					 return new AddExp(a, b);
			}
			case 7: // exp = LP.LP exp.a MULT.MULT exp.b RP.RP
			{
					final Symbol LP = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol MULT = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Exp b = (Exp) _symbol_b.value;
					final Symbol RP = _symbols[offset + 5];
					 return new MulExp(a, b);
			}
			case 8: // exp = MINUS.MINUS exp.a
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					 return new UnaryMinusExp(a);
			}
			case 9: // exp = LP.LP exp.a MINUS.MINUS exp.b RP.RP
			{
					final Symbol LP = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol MINUS = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Exp b = (Exp) _symbol_b.value;
					final Symbol RP = _symbols[offset + 5];
					 return new MinusExp(a, b);
			}
			case 10: // exp = LP.LP exp.a DIV.DIV exp.b RP.RP
			{
					final Symbol LP = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol DIV = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final Exp b = (Exp) _symbol_b.value;
					final Symbol RP = _symbols[offset + 5];
					 return new DivExp(a, b);
			}
			case 12: // exp = NUMBER.NUMBER
			{
					final Symbol NUMBER = _symbols[offset + 1];
					 return new de.tudresden.inf.st.most.jastadd.ast.Number(Float.parseFloat((String)NUMBER.value));
			}
			case 13: // exp = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new Var((String)IDENTIFIER.value);
			}
			case 11: // exp = LP.LP exp.a
			{
				return _symbols[offset + 2];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
